---

title: cpt 4 Inherit
date: 2017-12-2 10:10:00
tags:
- highlevel
- csharp
categories: program
thumbnail: https://i.imgur.com/iI24evE.jpg

---

# 第四章 继承 #

* Wrote : 2017-12-16 14:50:00
* Name  : NextLeaves

* 继承的类型
* 实现继承
* 访问修饰符
* 接口
* Is和As运算符

---

## 1. 继承 ##

* 封装、继承、多态

---
## 2. 继承的类型 ##

* 继承的方面的内容：
	1. 单重继承
	2. 多重继承
	3. 多层继承
	4. 接口继承

### 2.1 多重继承 ###

* 增加复杂性和一些开销
* 但可以多继承接口

### 2.2 结构和类 ###

* 结构只是继承与（System.ValueType类），但不支持继承，但是支持多重接口的继承
* 类默认继承自（System.Object类），或支持自定义选择的一个类作为基类，同时支持多重接口的继承

---
## 3. 实现继承 ##

* 若类没有指定基类，则默认选择System.Object为基类

### 3.1 虚方法 ###

* 关键字：virtual
* 也可以修饰虚属性
* 在**JAVA**中所有函数都是虚函数；**C#**默认不是虚函数，virtual修饰后才是虚函数，使用override重写
* 成员字段和静态函数不能声明为虚的，这个概念只对成员函数有意义

### 3.2 多态性 ###

* 使用多态性，可以动态地定义调用的方法，而不是在编译期间定义。编译器创建一个虚方法表（vtable）

### 3.3 隐藏方法 ###

* 如果函数的签名相同的情况下在基类和派生类中同时声明，且并没有使用virtual和override修饰符，那么派生类方法就会隐藏基类方法

### 3.4 调用基类版本 ###

* 关键字：base
* 好比喻base就是基类的对象

### 3.5 抽象类和抽象方法 ###

* 关键字：abstract
* 如果一个方法为抽象的，那么类也一定是抽象的
* 抽象的类是无法实例化的，同时不能实现具体的内容（函数体）
* 继承抽象类的时候，必须实现所有的抽象方法，否则编译器出错
* 或者可以抛出无实现的异常

### 3.6 密封类和密封方法 ###

* 关键字：sealed
* 如果不希望该类被派生，被修改，则可以选择密封类
* 最可能的情形：
	1. 保持类的稳定性，以免继承出现不稳定的问题
	2. 编译器提前预知密封类，可以减少virtual修饰符方便的内容，不创建虚拟表，可以提高性能
	3. string类是一个密封类，没有哪个应用程序不适用string类的，修饰为sealed用于提高性能
	4. 终止继承的操作（修饰密封方法，终止下一个子类重写方法）

### 3.7 派生类的构造函数 ###

* 构造函数总是按照类的层次结构进行调用的；先从**Object类开始**，然后是下一个类，最后是子类
* 若没有写子类的构造函数，则默认调用base()=>默认构造函数

---
## 4.修饰符 ##

* 修饰符类型：
	1. private
	2. protected
	3. internal：只能在该程序集使用
	4. public
	5. protected internal
	6. 上面的：124是逻辑修饰符，3是物理修饰符，其边界是程序集
* 嵌套类型：
	* 嵌套的类型可以访问外部类型的所有量

`

	class AClass
	{
		public class InnerClass
		{
			//InnerClass可以访问AClass的所有成员，包括私有成员
		}
	}

### 4.1 其他修饰符 ###

* 修饰符类型：
	1. new
	2. static
	3. virtual
	4. abstract
	5. override
	6. sealed
	7. extern

---
## 5. 接口 ##

* MIcrosoft的示例借口：
	* IDisposable
	* void Dispose()；
* 接口只能包含：事件、函数、属性、索引器
* 相比于**抽象类**的区别：
	* 抽象类，可以存在抽象方法和非抽象方法
	* 接口完全是抽象的内容，所以不用abstract修饰
* 继承的该接口的类，必须协同实现接口约定的同签名的函数和属性等

### 5.1 定义和实现接口 ###

* **Hungarian命名法：**在声明的类型前面加上一个大写字母；.NET不鼓励这种写法，但是接口是一个例外
* 接口引用的强大之处在于：可以引用实现该接口的所有类的实例，并且可以调用接口实现的方法或者属性；
* 如果要调用类实现的方法，则可以通过强制转换的方法使可以调用接口不具备的方法，所引用的类具有的方法
* 接口不具有System.Obeject方法，但是所有类都继承自Object类，所以直接调用Object的方法，为隐式转换

### 5.2 派生的接口 ###

* 接口也可以继承
* 继承的接口，具有父接口的所有内容，且类继承派生的接口，必须实现所有的方法和属性
* 例子：以IBankAccount和ITransferBankAccount为例子

---
## 6. is和as ##

* 若强制转换类型，可能导致InvalidcastException，导致类型为NullReferenceException
* 可以通过 as 关键字来进行转换，若转换失败的同时，会返回null，可以检测类型是否为null
* 也可以通过 is 关键字来进行判断，如果返回ture，再进行强制转换的形式
