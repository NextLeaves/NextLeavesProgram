---

title: cpt 4 Object And Type
date: 2017-11-28 23:13:00
tags:
- highlevel
- csharp
categories: program
thumbnail: https://i.imgur.com/UpMwJzE.jpg

---

# 第三章 对象与类型 #

* Wrote : 2017-11-28 23:13:00
* Name  : NextLeaves

* 类
* 结构
* 匿名类型
* 按值和按引用
* 可空类型
* 枚举
* 部分类
* 扩展方法
* Object类

---

## 3.1 创建及使用类 ##

* 讲述之前学习的是构成类的一些元素，现在组合在一起，组成一个叫完成的类
* 预先说明下一张的内容：继承以及继承的特性
* 若已经理解类的其中特性的原理；比如：构造函数、属性等，下面就是针对于C#来进行讲解

---

## 3.2 类和结构 ##

* 二者是创建的模板，都包含数据，同时提供对数据的处理和访问的方法
	* 类：数据具有固定的字段内容
	* 结构：较小的数据类型可以提高性能
	* （**类** 是引用类型，常具体数据分配在heap上、只是引用分配在stack上；**结构** 是值类型，分配在stack上；同时**不支持继承**）
	* （类 类型按照引用传递；结构 类型按照值传递）

---

## 3.3 类 ##

* 类包含**实例成员**和**静态成员**
	* 静态成员属于类：静态的字段值是一样的，且用static修饰
	* 实例成员属于对象：实例的字段值可以不同
* 成员的种类：
	* 字段
	* 常量
	* 属性：可以从客户端访问的函数组
	* 方法
	* 构造函数：用于初始化字段值
	* 索引器：允许通过下标访问数组
	* 运算符：数据的加法操作或者减法操作等；后续还会涉及运算符重载
	* 事件：是类中的一个成员，可以通过此包含事件对象的状态发生改变时，通知关注的对象，对应的做出变化的方式
	* 析构函数（又名：终结器）：CLR检测不再需要的对象，将进行垃圾回收机制（GC）；不可预测什么时候进行回收
	* 类型：存储其他**类**类型，或者其他**结构**类型；嵌套**类**类型

### 3.3.1 字段 ###

* 具体讲解字段（Custom类）
* 常量用const修饰
* **一般不要用public修饰字段**：修改公共成员变量字段的值，使每个调用此字段的对象也需要进行更改。例如：10个人用字段的值，若有一个人改变了，则全部都需要改变；则可以减少，或者不用编译

### 3.3.2 属性 ###

* 命名法则：
	* 私有字段使用小写字母命名；公有属性使用大写字母命名；利用Pascal命名法
	* 若存在等价的私有字段，则使用camel命名法
	* 现在微软使用下划线，作为区分字段的方法
* 自动实现的属性：不用生成私有字段
	* 简单的创建字段的替代品，的快捷方式
	* 可以利用属性初始化器 进行初始化
* 属性的访问修饰符：
	* 必须有一个具有属性的访问级别（简单说有一个必须是public，但不需要public来修饰）
	* 只有get访问器的属性；可以实现只读属性
	* 只有get访问器的自动属性；是C#6.0所具有的特性
* 担心过多的编码会导致性能的下降：
	1. C#代码会编译为IL；然后在JIT的运行下，编译为本地代码运行；JIT可以在合适的时候，随意的内联代码（内联代码来代替函数调用）
	2. 若一个代码实现函数或者属性只是通过一个函数的，那么它肯定是内联的函数
	3. MethodImpl属性，可以控制函数是否内联的控制（了解为主）

`

	//属性初始化器
	public string Name{get;set;}="Xiaoming";
	
### 3.3.3 方法 ###

* 正式的C#属于区分函数和方法；数据成员包含：字段、常量、事件；其他成员为非数据成员
* 方法的声明（略）
* 表达式体方法：利用=>进行的函数书写，且函数语句只有一条的情况下
* 调用函数（略）
* 方法的重载：
	1. 参数个数不同
	2. 参数类型不同
* 命名的参数：在调用函数的时候，可以书写参数名再赋值；真正的目的是为了**可选参数**

`

	//命名的参数：
	public string Message(string name,int age,int high);
	
	//调用时：
	Message(name:"Xiaoming",age:20,high:180);
	
* 可选参数：
	1. 必须是拥有默认值
	2. 必须是非默认值后面，即声明的时候在函数最右边
* 注意：
	1. 若默认值修改且没有重新编译，则调用旧的默认值；所以应该使用不会改变的默认值；否则就重新编译程序集
	2. 可选参数的版本控制问题
		* 一个问题：添加可选参数的数目
		* 二个问题：修改可选参数的默认值
		* 修改很简单，但是编译器会重新填充整个函数，之前的函数体就会失效
* 个数可变的参数：params修饰数组

`

	//个数可变的参数：
	public int Sum(params int[] number);
	//若想使用任何类型的参数
	public void AnyParametersOfArguments(params object[] object);
	//若与其他多个参数使用，则paras只能使用一次，且是声明的最后一个
	public void GetMessage(string name,params int[] ages);
	
### 3.3.4 构造函数 ###

* 默认构造函数的介绍：
	* 引用类型：默认为空
	* 值类型：默认为0
	* bool类型：默认为false
* 若自定义一个构造函数，则默认构造函数不存在
* 可以通过访问修饰符，修饰构造函数，可以让不相关的类型无法访问
	* 单例模式的实现
	* 不实例化对象，只使用静态方法
* 在构造函数中调用其他构造函数

`

	//在构造函数中调用其他构造函数
	public Custom(string expresstion):this(string expresstion,int age)
	{}
	
* 静态构造函数：只会执行一次；类中存在静态的字段和属性，用于在使用类之前，初始化静态字段和属性
	* 不因控制静态构造函数在什么位置执行，比如加载程序集的时候执行，所以不应该吧加载程序集的代码写在静态构造函数内
	* 不因控制不同类的静态构造函数的顺序，所以不要加以控制
	* 注意：静态构造函数没有访问修饰符；其他C#代码不显式调用，是通过.NET运行库进行调用
	* 不能带任何参数，且一个类只有一个静态构造函数
	* 静态构造函数，只能访问了类的静态成员，不能访问对象成员
	* 可以在同一个类中书写：静态构造函数和无参数的实例构造函数，不冲突
	* 如果有多个类具有静态构造函数，则不能确定类的相互影响，来控制类的静态构造函数的调用顺序
	* 若静态字段或者属性有默认值，则在静态构造函数中进行初始化

`

	//静态构造函数示例：
    namespace ConsoleApplication1
    {
        class Program
        {
            static void Main(string[] args)
            {
                Console.WriteLine(UserPreferences.BackColor);
            }
        }

        enum Color
        {
            Red,
            Green
        }

        static class UserPreferences
        {
            public static Color BackColor { get; }

            static UserPreferences()
            {
                DateTime now = new DateTime();
                if (now.DayOfWeek == DayOfWeek.Saturday || now.DayOfWeek == DayOfWeek.Sunday)
                {
                    BackColor = Color.Red;
                }
                else
                {
                    BackColor = Color.Green;
                }
            }
        }
    }
    
### 3.3.5 只读成员 ###

* 若不希望在后续修改字段的值，可以使用readonly修饰

### 3.3.6 只读属性 ###

* readonly与const的区别：
	1. 前者在构造函数中初始化，可以作为对象成员，也可以是类成员（用static修饰）
	2. 后者在调用的时候，编译器会直接替换为值（inline的形式）
* 只读属性：
	* 省略set访问器
	* 只写属性，省略get访问器，但是着通常不建议，会导致客户端作者迷茫；最好是通过方法来撰写
* 自动实现的只读属性：
	* 依然可以在构造函数中进行初始化
	* 也可以使用该自动初始化器来初始化
* 表达式体属性：
	* 可以直接get访问器的方式，输出信息
* 不可变的类型：
	* 一个类若包含有可以改变的类型，则为可变类型；若一个类全部有readonly等修饰，则只能在构造函数中初始化，则成为不可变类型
	* 这对于多线程有重要意义：因为多个线程进行访问，因为内容是不变的，所以就不需要同步
	* 举例：String类，没有定义任何改变其内容的成员，比如：ToUpper，总是返回一个新的字符串，传递到字符串的原始字符串不变

---

## 3.4 匿名类型 ##

* 匿名类型：表示隐式类型化的变量；只是继承自object且没有类型名的类
* 所有属性匹配，则为同一个类型，可以进行赋值操作
* 不应使用反射来获取匿名类型对应的类型名

---

> 回顾上一节内容：

1. 封装数据
2. 存储的位置
3. 数据的生存期

---

## 3.5 结构 ##

* 使用类，可以拓展很多方面；但是有时候只需要小的数据类型；在heap的优化，可以减少性能损失，但是更好的方法是使用结构，来提高性能
* 存储简单的数据类型，进行简单的运算操作
* 结构不支持继承
* 若没有构造函数，则有一个默认构造函数
* **使用结构，可以指定字段如何在内存中布局**

`

	public struct Dimension
	{
		public double _high;
		public double _width;
		public double Square(double high=_high,double width=_width)=>high*width;
	}
	
### 3.5.1 结构是值类型 ###

* 虽然结构是值类型，但是当做类的方式来处理；new只是调用构造函数，而不分配内存
* 结构类型必须初始化后才能使用
* 优点：
	* 分配快，在stack中，inline
	* 释放快，不需要等待垃圾回收
* 缺点：作为参数进行传递的时候（结构体要用于小的数据存储）
	* 使用ref引用调用，减少性能的损失
	* 若单纯的调用，则会进行值的复制
* 结构和继承：虽然结构无法继承，但是结构是继承下来的类型
	* System.Object->System.ValueType->Struct
	* 意味着Struct可以修改Object的方法，如：ToString()
* 结构的构造函数（C#6）：可以在默认构造函数中，初始化字段值；在C#6之前，为实现此功能

### 3.5.2 按值和按引用传递参数 ###

* 值是复制，引用传递实际的参数
* ref参数：让值类型传递引用的方式
* out参数：可以返回多个值

### 3.5.3 可空类型 ###

* 引用类型的类型可以为空，但是值类型的变量不能为空
* 问题：数据库和XML的值类型可以为空，导致出现问题所在
* 处理方式：
	* （java处理方式）使用隐射到数据库类型的类，来处理值类型为空的操作；需要进行类型的分配和垃圾处理机制
	* （C#处理方式）使用可空类型，格式：int？，唯一的开销为bool类型，来判断是否为空
* 可空类型的属性：HasValue：判断是否有值；再使用Value来获取值

### 3.5.4 枚举 ###

* 可以限制枚举的类型；既可以强制转换为枚举，也可以枚举强制转换值
* 使用[Flags]特性：
	* 实现多种符合的状态（位域）
	* 使用16进制来标志，设置不同的位
	* 通过与运算，把值转换为二进制，然后进行01的判断

### 3.5.5 部分类 ###

* partial关键字：允许把类、结构、方法、结构放在其他文件中
* 应用于所有类的修饰：
	* public
	* private
	* protected
	* sealed
	* new
	* internal
	* abstract
	* 一般约束
* 部分类，可以包含部分方法：在一个部分类中声明方法；在另一个部分类中实现方法
	* 必须是void返回值类型，因为在没有实现部分方法时，无法删除未实现的部分方法

### 3.5.6 扩展方法 ###

* 给类添加方法的好办法是：继承；还有一个方法就是扩展方法
* 例子：假如希望扩展String类的方法，计算字符串的中单词的数目
* 格式：
	1. 静态的类进行扩展：Public Static class StringExtension{}
	2. 函数参数为this修饰扩展的类型
	3. 即使是**静态的函数**，但是同样通过**对象来书写**；编译器会修改为静态访问方式，用于区分，扩展方法
* 如果在扩展函数的原函数中有同名函数，则优先调用原函数
* 且扩展函数，需要包含在相对应的原函数所拥有的命名空间内
* Linq(Language Integrated Query)语法，运用很多扩展方法的写法

`

	public static class StringExtension
	    {
	        public static int WordsofCount(this string s) => s.Split(" ").Length;
	    }
	
	    class A
	    {
	        public string x;
	
	
	    }
	
	    static class AExtension
	    {
	        public static void SendMessage(this A a) => Console.WriteLine(a.x);
	    }
    
## 3.6 Object类 ##

* 所有类的继承者
* 意义在：可以访问Object类定义的公有和受保护的成员方法
	* ToString（）:获取对象的类型（字符串形式）
	* GetHashCode（）：若对象放在名为散列表或者字典的数据结构中时，提取hash值
	* Equals（）和ReferenceEquals（）
		* 前者：
		* 后者：
	* Finalize（）：对象作为垃圾的时候调用
	* GetType（）：获取对象所属的类型
	* MemberwiseClone（）：返回值，对副本的引用；对于值类型，就是装箱的引用