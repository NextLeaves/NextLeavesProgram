---

title: cpt 5 Unmange and mange source
date: 2017-12-4 13:30:00
tags:
- highlevel
- csharp
categories: program
thumbnail: https://i.imgur.com/UpMwJzE.jpg

---

# 第五章 托管资源和非托管 #

* Wrote : 2017-12-4 13:30:00
* Name  : NextLeaves

* 运行期间在**栈**和**堆**上分配空间
* 垃圾回收
* 使用析构函数和实现**IDispose**接口来释放非托管资源
* C#中使用指针的语法
* 使用指针实现基于栈的高性能数组
* 平台调用，访问本机API

---

## 1. 资源 ##

* 资源：是一个被反复使用的术语
* 托管和非托管的资源---存储在托管或本机堆中的对象
	* 垃圾收集器（GC）只能释放存储在托管堆中的对象，但是无法释放本机堆中的资源，必须由开发人员进行释放
* 了解内容：
	1. GC如果工作？
	2. 什么数据类型存储在堆栈的什么位置，以及方式
	3. 什么是**大小对象堆**
	4. 以及框架中存在的本地的方式，比如文件包装了一个本地文件的句柄，需要程序员自己进行释放

## 2. 后台内存管理 ##

* C#的其中一个优点是程序员不需要关心任何编写的托管代码部分，因为其中存在CLR的GC机制来处理和释放所有托管中的代码；已至于简化C#的后续处理事情，像C++一样更高的效率来处理应用程序
* 但是程序员也应该理解，分配内容时，在内存分配的一些机制和方式

### 2.1 值数据类型 ###

* windos使用的虚拟寻址系统
* 32位处理器在处理32位应用程序时，只能利用4Gb的内存空间
	* 其中内存存储空间包括：
		1. 可执行代码
		2. 代码加载的所有DLL
		3. 以及程序在实际上包含了所有的变量
	* 这个空间被称为虚拟空间和虚拟地址或者虚拟内存
* 在编译器中，Debug模式下，可以使用x86和x64不同模式下调试
* 虚拟内存单元，都是从0开始往上开始排序的
* 虚拟内存中有一个区域叫做**stack**，存储不是对象成员的值类型
* 对于作用域的相关问题：
	* 先分配的变量，和后分配的变量，其后者的作用域更短
	* 栈释放变量的时候，总是和分配变量的顺序相反，这就是栈的工作方式
	* 什么是**块作用域**和**结构作用域**？
* 栈的存储方式：栈从上往下进行存储，即从高内存地址到低内存地址的过程存储
* 如果像是i，j这种同时分配的栈类型的数据；对于程序员来说，谁先进行分配的已经不重要了，因为运行时会保证先分配的空间会后被释放，也就保证了正常的生存周期

### 2.2 引用数据类型 ###

* 栈具有高性能的优势，但是在存储多数据的情况下，且很长时间后还能继续使用的话，就要使用new创建的类型，来在heap中生成对象
* heap的分配方式，从下往上进行分配的，所以空闲堆在空间的上方
* 可以在栈中使用两个引用变量，这样栈中存在两个引用变量指向栈中的数据实例；只要有变量实例有引用栈，则具体的数据不会消失，至于没有引用变量之后，接下来就有GC来处理变量实例的垃圾回收机制

### 2.3 垃圾回收 ###

* 因为堆中的数据存储的方式不像栈一样，连续的；可能在后面才会删除中间存在未引用的变量实例，所以在GC运行的时候，会释放不再引用的变量实例，然后再把堆中存储的数据实例，依次的向上排列，这样保证下一次分配大数据空间的时候，不需要再次寻找合适的存储空间，保证推中空间的连续使用
	* 当然保证栈中引用的修改后的数据存储空间
* 强制某个地方调用垃圾回收机制：System.GC.Collect():
	* 在大量消失对象引用的时候，可以强制调用
	* 但是仍不能保证所有的未引用的实例被释放
	* 让GC中待释放的对象，更快的移动到下一代
* 堆的分布问题：
	* **新分配的对象**被称为第0代；直到第一次调用垃圾回收机制时候
	* 第一次调用GC后遗留下来的对象：被称为第1代，依次根据GC的调用来分布堆中的对象分布
* 如果超出第0代，或者调用GC的时候，就会进行对象的释放
* 保证了释放对象的高效率，一般保存的越久的对象，越不容易释放，保证了越容易释放的对象，排序在相同的位置，更利于垃圾的回收
* 另一个提高性能，处理堆上的大对象时：利用**架构处理堆**
	* 大对象存在自己的大对象托管堆
	* 大于85000个字节的对象，存储在**非主堆**上，而是**大对象堆**上
	* 在大对象上执行压缩是比较昂贵的，所以大对象一般不执行压缩操作
	* 默认在第0代和第1代执行回收和阻塞操作，这样减少总的阻塞时间
* 另一个提高性能，垃圾回收平衡机制：
	* 专用于服务器的垃圾回收
	* 在虚拟服务器上存在线程池的逻辑，如果单个线程的所利用的空间用完，导致触发垃圾回收机制，这样会同时引起其他线程的垃圾回收机制，这样可能其他线程不需要垃圾回收，这样导致性能很低
	* 平衡上述过程，按权分配内存，保证内存的相互的足够使用
* 为了利用包含大量内存硬件，垃圾回收机制添加了**GCSettings.LatencyMode**枚举，控制垃圾回收的方式

## 3. 强引用和弱引用 ##

* 只要有一个变量引用类型，则该引用为强引用
* **提醒：**使用事件很容易错过引用的清理，此时可以使用弱引用
* 弱引用：允许创建和使用对象，但碰巧GC运行，则就会回收对象，并释放内存；由于存在潜在的bug和和性能问题，一般不会这么做
	* 弱引用不适合用于小对象，因为弱引用也存在性能消耗，可能比小对象更消耗性能
	* WeakReference类，传递一个强引用到该类的构造函数，实现创建一个弱引用
		* Target属性可以返回一个强引用
		* IsAlive属性，判断是否还存在实例数据

## 4. 处理非托管的资源 ##

* 垃圾回收机制无法对非托管资源进行回收；例如（文件句柄、网络连接、数据库连接）
* 在封装托管类时，添加直接或者间接添加非托管类时，需要对此类进行特殊的构造，有两种不同的解决方法：
	1. 声明一个析构函数（或者终结器），作为类的一个成员
	2. 在类中实现IDisposable结构

### 1. 析构函数或终结器（Finalizer） ###

* C#的源代码中析构函数，实际会被翻译为终结器（Finalizer），重载Object类的Finalize()
* **其中一个问题：**因为C#中GC的存在，所以析构函数不一定会立即执行，所以不应该在代码中放置重要的且立即执行的任务，同时也不应加以约束每个析构函数中执行的顺序，因为是不确定性的
* **又一个问题：**与析构函数的类会延迟对象从内存中的释放；使用GC所释放的对象资源会立即从内存中释放空间；但是调用析构函数的对象，第一次是调用析构函数，第二次才是从内存中释放空间。运行库使用一个线程来调用所有对象的析构函数，如果析构函数过多，必将影响应用程序的性能

### 2. IDisposable接口 ###

* 在C#中推荐使用，实现此接口的方式来释放非托管资源；其接口具有的模式（具有语言级的支持），避免了析构函数与GC中存在的问题，导致延迟释放内存
* 显式的实现Dispose()，这样精准的控制调用终结器的过程
* 保证释放的过程顺利的话，应使用try..catch块，进行保证没有意外出现

### 3. using语句的使用 ###

* 但是try..catch块会混淆其真正的功能，所以推出using(){}结构的写法，来可以直接在对象超出作用域的时候，自动调用Dispose(0函数，来实现资源的释放
* 有的类，比如数据库的连接，通常是使用Close()来关闭非托管资源；Close()函数，只是调用Dispose()函数；所以新类只需要实现IDisposbale接口的方法，然后使用using结构来释放非托管资源

### 4. 实现IDisposable接口和析构函数 ###

* 当Dispose()函数未实现，析构函数的实现，作为双重保证 
* GC.SuppressFinalize(this)，代表禁止调用析构函数，表明该类未实现析构函数

### 5. IDisposable和终结器的规则 ###

* 释放代码是托管代码的一个重要机制
* 总结的规则如下：
	1. 如果该类的成员有实现IDisposable接口的成员，则该类也应该实现DIspose()方法
	2. 实现IDisposable接口，并不意味着一定要实现终结器，因为此机制是生成对象，实现释放资源的方式，会对GC造成一定的性能损失，所在在必要的时候才实现。**比如：发布本机资源，释放本机资源，就需要终结器（未理解的知识点）**
	3. 实现了终结器，也应该实现IDisposable接口，这样可以提前释放资源，不必在GC寻找到需要释放资源的时候，再进行资源的释放
	4. 在终结器中，不能访问以终结的对象；终结器的调用顺序是不能加以控制的
	5. 如果在使用一个实现IDispoable接口的方式的对象，在不需要对象的时候调用Dispose()方法，实现对资源的释放；使用using语句比较方法，同时只需要实现IDisposable接口即可