---

title: cpt 5 Singleton Pattern
date: 3/2/2018 8:38:59 PM 
tags:
- designpattern
- csharp
categories: designpattern
thumbnail: https://i.imgur.com/WiBfKkJ.jpg

---

# 第五章 单例模式 #

* Wrote : 3/2/2018 8:39:18 PM 
* Name  : NextLeaves

* 引出单例模式
* 单例模式的写法
* 巧克力工厂的故事
* 多线程模式下的单例模式

---

## 1. 引出单例模式 ##

* 单例模式适用的场景：
	* 线程池管理，注册表管理，缓存，日志对象，作为打印机驱动的程序对象
* 不用全局和静态的原因：
	* 一开始就生成的资源，如只是偶尔使用，则会造成资源的浪费

## 2. 单例模式的写法 ##

* 步骤：
	* 1. 构造函数私有化
	* 2. 创建类中的全局访问点，即GetInstance()
	* 3. 创建uniqueInstance对象

## 3. 与模式“先生”的对话 ##

* 只生成一个对象，并不是对资源的浪费，更是为了接下来的更好的管理
* 没有公共的构造函数，提供全局的访问点，是实现单例模式的重要环节

## 4. 巧克力工厂的故事 ##

* 情景：巧克力工厂用于生产巧克力棒，实现的环节是：有一个巧克力加工机器，制作出巧克力棒；对其要求是，必须在加满的时候且没有煮沸过的时候才能煮沸，空的时候，不能进行煮沸，也不能进行收货；只有在满的时候才能进行收货等苛刻的要求
* 为此书写一个chocolateBoiler类
	* 实现Fill(),Drain(),Boil()

## 5. 单例模式的定义 ##

* **单例模式：确保一个类只有一个对象，并且提供全局访问点。**

## 6. 问题扩展-多线程下的单例模式 ##

* 对于多线程下的单例模式，会造成错误的情况，导致创建不一样的对象；原因在于多线程同时创建，造成编译器无法判断哪一个创建的才属于
* **volitile**关键字，修饰字段，保证字段在多线程的同时处理下，一直保持最新值
* 可以增加一层同步判断
	* java中：修饰构造函数sychronized
	* c#中：lock()锁定线程
* 引发的问题：
	* 1. 同步判断，会导致性能的下降，一直处于判断状态
	* 2. 其实针对同步，只有第一次才需要同步，后续并不需要同步操作
* 解决办法：
	* 1. 急切性方案，即等同于全局变量的方式；在一开始的时候就生成好对象，此后就不需要再生成对象了
	* 2. 双重锁定判断，即先判断是否为空，若为空再同步判断是否为空的方式

## 7. NO DUMB QUESTIONS ##

* 1. 看似简单的单例模式，实则还是有很多学问？
* 2. 可否用静态方法，替代单例模式？
* 3. 针对于有类加载器的机制的java，又怎么处理？
	* 使用修饰，限制不同类加载器的访问
* 4. 谣传GC会清理未引用的单例对象，此为java1.2之前版本的bug
* 5. 对于单一职责原则，单例模式是否违反？
* 6. 单例设为超类，是否有必要继承操作？
	* 继承，必须构造器为**公共**或**保护**
* 7. 全局变量比单例模式差的原因？
